## 兔子繁殖

有一对小兔子，小兔子过Z个月长大，一对大兔子X个月生Y对小兔子，求n个月后的兔子总对数。

当x y z都是1的时候，f(n)=f(n-1)+f(n-2)

有一对小兔子，小兔子过5个月长大，一对大兔子3个月生4对小兔子，求n个月后的兔子总对数。

f(n)表示n个月后的兔子总数
f(n)=n那个月原有的兔子+n那个月新生的兔子
n那个月原有的兔子是：f(n-1)
n那个月新生的兔子是：n-x那个月成熟的兔子，也就是n-x-z那个月所有的兔子，因为n-x-z那个月所有的兔子在n-x那个月的时候都成熟了

故f(n)= f(n-1)+ f(n-x-z) * (y/x)；这里必须是* (y/x)，这是每个月生产的。(那个月成熟的兔子在一个月里生的小兔子的个数）

这个表达式也适合于一个月生一对的情况；
一个月的情况可以看成成熟+不成熟，和原来的+新生的。而多个月的情况看成后一种比较好，因为看成前一种会超级麻烦。

到本题，也就是f(n)= f(n-1)+ f(n-8)*(4/3)；

# 列表更新

动机: 一般常见都是用来更新`dom`时使用, 需要最少的更新量

步骤:

1. 区分出需要删除的元素, 新增的元素, 保留的元素三组
2. 删除需要删除的元素
3. 保留的元素使用新列表中的顺序添加标号, 求其最长递增子序列, 即最多的不需要移动的元素
4. 保留的元素 - 不需要移动的元素 = 需要移动的元素, 需要移动的元素和新增的元素按标号顺序插入

具体实现:

在所有步骤之前可以有一个针对特定场合的优化, 即变动是序列中的少量变化, 头尾几乎不变.

通过从头和从尾开始两个方向同时移动指针, 比较, 获得中间的一个差异区域, 在大量内容小改动时这个优化效果极佳. `O(n)`

接着就是列表更新了

对于步骤1, 使用一个字典辅助

1. 遍历旧列表, 每个元素的`id`作为字典的一个key, 对应元素为`{old: 1}`即可
2. 遍历新列表, 同上, 对于元素为`{new: 1}`
3. 遍历这个字典来区分出三类元素, 即: `{old: 1}`是需要删除的元素, `{old: 1, new: 1}`是保留的元素, `{new: 1}`是新增的元素

`O(n)`

对于步骤2, `O(n)`

对于步骤3, 属于最长递增子序列的问题, 比较好的算法可以达到 `O(nlogn)`

对于步骤4, 可以二分查找插入, `O(logn)`

# 最长递增子序列

## O(n^2)的一个算法

核心思想是这样的:

假设序列为一个数组`arr`, 长度为`n`, 使用`i`来索引数组元素, `i`满足`0 <= i < n` 

若`arr[i]`是`arr.slice(0, i + 1)`中的一些递增子序列的最后一个元素, 则这些递增子序列中最长的记为`L(i)`

要求`L(i)`的最大长度, 可以这么做, 只关注`arr.slice(0, i)`中所有比`arr[i]`小的元素, 这些元素`arr[a], arr[b], arr[c]...`分别对应`L(a), L(b), L(c)...`, 而`L(i) = Max(L(a), L(b), L(c)...) + 1`

如此, 从后往前, 再计算`L(a), L(b), L(c)...`,是个自顶向下的递归的过程, 分支过多, 且有重复计算.

实际实现时使用自底向上, 即从数组头部开始, 依次计算`L(0)`, `L(1)`, `L(2)`...

一遍下来就是`O(n^2)`的复杂度, 最后在所有`L(x)`中选择最大的那个, 再回溯(当然应该在过程中保存这条路径), 就获得了整个序列的最长递增子序列了

# 布隆过滤器(Bloom Filter)

高效判断一个值是否不存在, 但存在则是概率性的